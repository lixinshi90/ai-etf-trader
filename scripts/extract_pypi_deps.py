#!/usr/bin/env python3
"""
Extract pure PyPI dependencies from requirements.txt
Remove Conda-specific local file paths

Usage:
    python scripts/extract_pypi_deps.py
    python scripts/extract_pypi_deps.py -o cleaned_requirements.txt
"""

import re
import sys
from pathlib import Path
from typing import List, Tuple


def parse_requirements(file_path: str) -> Tuple[List[str], List[str]]:
    """
    Parse requirements.txt and separate PyPI packages from local files.
    
    Returns:
        Tuple of (pypi_packages, local_files)
    """
    pypi_packages = []
    local_files = []
    
    with open(file_path, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            
            # Skip empty lines and comments
            if not line or line.startswith('#'):
                continue
            
            # Check if it's a local file reference
            if '@ file://' in line or line.startswith('file://'):
                local_files.append(line)
            else:
                pypi_packages.append(line)
    
    return pypi_packages, local_files


def clean_package_spec(spec: str) -> str:
    """
    Clean package specification.
    Remove any remaining file:// references.
    """
    # Remove file:// URLs
    spec = re.sub(r'\s*@\s*file://.*', '', spec)
    return spec.strip()


def main():
    """Main function."""
    import argparse
    
    parser = argparse.ArgumentParser(
        description='Extract pure PyPI dependencies from requirements.txt'
    )
    parser.add_argument(
        '-i', '--input',
        default='requirements.txt',
        help='Input requirements.txt file (default: requirements.txt)'
    )
    parser.add_argument(
        '-o', '--output',
        default='cleaned_requirements.txt',
        help='Output file for cleaned requirements (default: cleaned_requirements.txt)'
    )
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Show detailed information'
    )
    
    args = parser.parse_args()
    
    # Check if input file exists
    if not Path(args.input).exists():
        print(f"âŒ Error: {args.input} not found")
        sys.exit(1)
    
    print(f"ğŸ“– Reading {args.input}...")
    pypi_packages, local_files = parse_requirements(args.input)
    
    # Clean package specs
    cleaned_packages = [clean_package_spec(pkg) for pkg in pypi_packages]
    cleaned_packages = [pkg for pkg in cleaned_packages if pkg]  # Remove empty
    
    # Print summary
    print(f"\nğŸ“Š Summary:")
    print(f"  Total lines: {len(pypi_packages) + len(local_files)}")
    print(f"  PyPI packages: {len(cleaned_packages)}")
    print(f"  Local files (removed): {len(local_files)}")
    
    if args.verbose:
        print(f"\nâœ… PyPI Packages ({len(cleaned_packages)}):")
        for pkg in sorted(cleaned_packages):
            print(f"  - {pkg}")
        
        if local_files:
            print(f"\nâŒ Local Files (removed) ({len(local_files)}):")
            for f in local_files:
                # Truncate long paths
                if len(f) > 80:
                    f = f[:77] + "..."
                print(f"  - {f}")
    
    # Write cleaned requirements
    print(f"\n[object Object] {args.output}...")
    with open(args.output, 'w', encoding='utf-8') as f:
        f.write("# Cleaned requirements.txt\n")
        f.write("# Generated by extract_pypi_deps.py\n")
        f.write("# Local file references have been removed\n\n")
        for pkg in sorted(cleaned_packages):
            f.write(f"{pkg}\n")
    
    print(f"âœ… Done! Cleaned requirements saved to {args.output}")
    
    # Show comparison
    print(f"\nğŸ“ Comparison:")
    print(f"  Original: {args.input} ({len(pypi_packages) + len(local_files)} lines)")
    print(f"  Cleaned:  {args.output} ({len(cleaned_packages)} lines)")
    
    return 0


if __name__ == '__main__':
    sys.exit(main())

